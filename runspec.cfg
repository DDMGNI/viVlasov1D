

[grid]

nt   = integer(default=100)            # number of timesteps
nx   = integer(default=101)            # number of spatial  grid points
nv   = integer(default=101)            # number of velocity grid points

ht   = float(default=0.01)             # length of timestep

L    = float(default=0.0)              # spatial domain
vmin = float(default=0.0)              # velocity domain
vmax = float(default=5.0)              # velocity domain


[solver]

type = option('linear', 'nonlinear')             # use linear or nonlinear solver, not implemented yet
mode = option('full',   'split')                 # solve the full system at once or iterate between
                                                 # Vlasov and Poisson equation, not implemented yet
method = option('direct', 'iterative', 'matrixfree')
                                                 # use direct LU solver, matrix-based iterative GMRES solver,
                                                 # or matrix-free iterative GMRES solver, not implemented yet

initial_guess = option('rk4', 'gear', 'symplectic2', 'symplectic4', default=None)
                                                 # compute initial guess via RK4, Gear or symplectic method

lu_package = option('mumps', 'pastix', 'superlu_dist', default='mumps')
                                                 # direct solver package for LU decomposition 

initial_iter        = integer(default=1)         # number of iterations for initial guess 

petsc_ksp_rtol      = float(default=1E-7)        # PETSc linear solver relative convergence tolerance
                                                 # (relative decrease in the residual norm)
petsc_ksp_atol      = float(default=1E-10)       # PETSc linear solver absolute convergence tolerance
                                                 # (absolute size of the residual norm)
petsc_ksp_max_iter  = integer(default=1000)      # PETSc linear solver maximum number of iterations

petsc_snes_rtol     = float(default=1E-20)		 # PETSC nonlinear solver absolute convergence tolerance
petsc_snes_atol     = float(default=1E-12)		 # PETSC nonlinear solver relative convergence tolerance
petsc_snes_stol     = float(default=1E-14)		 # PETSC nonlinear solver convergence tolerance in terms
                                                 # of the norm of the change in the solution between steps
petsc_snes_max_iter = integer(default=20)	     # PETSC nonlinear solver maximum number of iterations


coll_freq    = float(default=0.0)                # collision frequency
coll_diff    = float(default=1.0)                # weight of diffusion term, not implemented yet
coll_drag    = float(default=1.0)                # weight of drag term, not implemented yet


[initial_data]

mass         = float(default=1.0)           # particle mass, not yet implemented consistently
charge       = float(default=1.0)           # particle charge

density      = float(default=1.0)           # constant density
temperature  = float(default=1.0)           # constant temperature

distribution_file = string(default=None)    # load distribution profile from file, not implemented yet
density_file      = string(default=None)    # load density      profile from file, not implemented yet
temperature_file  = string(default=None)    # load temperature  profile from file, not implemented yet
potential_file    = string(default=None)    # load potential    profile from file, not implemented yet

# Here, you can specify Python modules that contain functions are called by
# distribution(grid), density(grid), temperature(grid), potential(grid)
# which return a NumPy array of size (grid.nx, grid.nv) or (grid.nx).
# Just give the module name (without the trailing .py).
 
distribution_python = string(default=None)  # calculate distribution profile
density_python      = string(default=None)  # calculate density      profile
temperature_python  = string(default=None)  # calculate temperature  profile
potential_python    = string(default=None)  # calculate potential    profile
external_python     = string(default=None)  # external  potential    profile

# The code is proceeding as follows
# 
# check if distribution_python is given
#    if so use that to compute f
# else
#    check if density_python     is given, else use constant density
#    check if temperature_python is given, else use constant temperature
#    compute a Maxwellian distribution function according to the above
# normalise f such that the average density equals one
# compute density and potential
#


[io]

output_dir  = string(default=".")          # output directory
nsave       = integer(default=1)           # save every nsave'th timestep

hdf5_input  = string(default=None)         # restart run from hdf5 file, not implemented yet
hdf5_output = string(default=None)         # write data to hdf5 file, not implemented yet

